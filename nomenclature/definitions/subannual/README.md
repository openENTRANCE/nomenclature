# Guidelines for subannual data resolution

The **subannual** column in the data format specifies the temporal scope
of the timeseries data at a sub-annual resolution.
The column is **not required**; if it is not provided,
the timeseries is understood as yearly data.
The default value for this column is 'Year'.

*This column is an extension compared to the format as defined by the
[IAMC](http://www.globalchange.umd.edu/iamc/) and used in the context
of IPCC Reports and other model comparison studies.
These previous scenario ensembles only used yearly timeseries data.*

## Overview

The list of subannual "timeslices" are grouped into several categories
and levels of temporal detail.
Timeslices can be either understood as consecutive periods or as
representative periods (e.g., "summer-day").

Each item in the codelists below includes an attribute `duration` indicating
the duration relative to a normal year (i.e., not a leap year).

### Yearly data

The default entry for the openENTRANCE data format in the "subannual" column
is "Year". Its `duratuon` attribute is set to`1`.

### Months

See [months.yaml](months.yaml) for the codelist.

#### Example for using this codelist

The code snippet (Python) below shows how to obtain a mapping of months
to their respective duration.

```python
import yaml
with open(f'../subannual/months.yaml', 'r') as stream:
    months = yaml.load(stream, Loader=yaml.FullLoader)

mapping = dict([(m, eval(attr['duration'])) for (m, attr) in months.items()])
```

### Daily and hourly data

#### Continuous-time format:
It refers to consecutive timestamps that use a timestep resolution (equal or different to one hour).
Our convention makes reference to the following agreements:

- Standard datetime format              : **UTC**  
> The UTC datetime format is adopted to consider the following levels: day, hour, minute, and second if it is necessary (without considering time zones).
> For example: `2020-01-01, 2020-01-02, ...` or `2020-01-01T13:00, ...`
> The use of lists of dates and datetimes will be generated by the codes of the next section.

- Hour duration                         :
> It is understood that `2020-01-01T00:00` represents the duration from midnight until 1 a.m. (or whatever the next data point is in a multi-hour timestep resolution). For example: if we have a timestep equal to 2, the next data point will be 2 a.m.
> The multi-hour timestep resolution is the total responsibility of the modeling team that must transform the data as part of the input/output processing workflow.

- Calendar                              : **Use of real days**  
> For any model with an hourly resolution, it assumes that uses 8760 hours for a common year and 8784 hours for leap years as 2020, 2024, etc.

- Using time zone                       : **Everything is in the same time zone (Berlin, Vienna, Paris, Madrid, etc.)**
> To emphasize that all-time data must be given in UTC format. And, do not include the special treatment for identifying time zones.

- Summer/Winter-time in continuous-time format :
> It is the total responsibility of each modelling team that must transform the data as part of the input/output processing workflow because the validate() function of nomenclature will validate how the timestamps are provided but it won't recognize the difference between UTC and local time as well as nor transform data from each other.

#### Representatives timeslices:
It refers to clustered hours and not consecutive that generates representatives timeslices. Some agreements are reflected in the following:

- Using winter/summer time as representatives timeslices  :
> To distinguish between different granularity levels of representative timeslices, It was proposed the following: `<Granularity>|<Name of timeslice>`. For example: `2 Season-2 Times|Summer-Day`.

- Averaging values over the time span   :
> A value is always the average for flow variables (i.e. It is the average between the subannual time and the subsequent one, where average is contingent on the lowest level of granularity - if you use 2020-01-01T13:00, it is hourly average, if you use 2020-01-01, it is daily average...).

- Accumulating values over the time span:
> A value at the start of the period for stock over the time-period until the start of the next timeslice.
> For example, Capacity or Reservoir Level at 2020-01-01T13:00 is the value at 1pm, if subannual is given as 2020-01-01, it is understood as midnight that day, if it's January, it is understood as midnight on the first day of the month.


#### Using the format:

The code snippet (Python) below shows how to get lists of dates and datetimes.

- To get a list of dates:
```python
from datetime import timedelta, date

def daterange(date1, date2):
    for n in range(int ((date2 - date1).days)+1):
        yield date1 + timedelta(n)

start_dt = date(2015, 12, 20)
end_dt = date(2016, 1, 11)
for dt in daterange(start_dt, end_dt):
    print(dt.strftime("%Y-%m-%d"))
```
<!-- - To get a list of datetimes:
```python
from datetime import timedelta, datetime

def DateTimeRange(datetime1, datetime2):
    for n in range(int (((datetime2 - datetime1).days)+1)*24):
        yield datetime1 + timedelta(hours=n)

start_dt = datetime(2020, 6, 23)
end_dt   = datetime(2020, 6, 30)
for dt in DateTimeRange(start_dt, end_dt):
    print(dt.strftime("%Y-%m-%d %H:%M:%S"))
``` -->

The format `"%Y-%m-%d %H:%M:%S"` is composed by tokens. Each token represents a different part of the date-time, like day, month, year, etc. More details can be found in [strftime() and strptime() Format Codes](https://docs.python.org/3/library/datetime.html).
For a quick reference, here is what we're using in the code above:

- %Y: Year (4 digits)
- %m: Month
- %d: Day of month
- %H: Hour (24 hour)
- %M: Minutes
- %S: Seconds

### Other categories

*Other categories to be added over time*
